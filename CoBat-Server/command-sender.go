package main

// Connect, subscribe on channel, publish into channel, read presence and history info.

import (
	"database/sql"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"time"

	"github.com/centrifugal/centrifuge-go"
	_ "github.com/lib/pq"
)

var database *sql.DB

type testMessage struct {
	Input string `json:"input"`
}

// MicManager owo
type MicManager struct {
	Order  string `json:"order"`
	File   string `json:"file"`
	Name   string `json:"name"`
	Buffer string `json:"buffer"`
}

type eventHandler struct{}

func (h *eventHandler) OnConnect(c *centrifuge.Client, e centrifuge.ConnectEvent) {
	log.Printf("client connected")
}

func (h *eventHandler) OnDisconnect(c *centrifuge.Client, e centrifuge.DisconnectEvent) {
	log.Println("client diconnected")
}

type subEventHandler struct{}

func (h *subEventHandler) OnPublish(sub *centrifuge.Subscription, e centrifuge.PublishEvent) {
	fmt.Println(string(e.Data))
	// log.Println(fmt.Sprintf("New publication received from channel %s: %s \n", sub.Channel(), string(e.Data)))
	var data MicManager
	json.Unmarshal(e.Data, &data)
	if data.Order == "" {
		a, err := base64.StdEncoding.DecodeString(data.Buffer)
		fmt.Println(err)
		ioutil.WriteFile("./audio.mp4", a, 0644)
	}
}

func (h *subEventHandler) OnJoin(sub *centrifuge.Subscription, e centrifuge.JoinEvent) {
	log.Println(fmt.Sprintf("User %s (client ID %s) joined channel %s", e.User, e.Client, sub.Channel()))
}

func (h *subEventHandler) OnLeave(sub *centrifuge.Subscription, e centrifuge.LeaveEvent) {
	log.Println(fmt.Sprintf("User %s (client ID %s) left channel %s", e.User, e.Client, sub.Channel()))
}

func main() {

	// pgsql:host=localhost;port=5432;dbname=db;user=user;password=pwd
	psqlInfo := "host=127.0.0.1 port=5432 dbname=db user=user password=pwd"
	db, err := sql.Open("postgres", psqlInfo)
	if err != nil {
		panic(err)
	}
	defer db.Close()

	database = db

	fmt.Println("Database Connected !")

	url := "ws://localhost:8000/connection/websocket?format=protobuf"

	c := centrifuge.New(url, centrifuge.DefaultConfig())
	// c.SetToken("eyJ0....")
	defer c.Close()

	eventHandler := &eventHandler{}
	c.OnConnect(eventHandler)
	c.OnDisconnect(eventHandler)

	err = c.Connect()
	if err != nil {
		log.Fatalln(err)
	}

	sub, err := c.NewSubscription("public")
	if err != nil {
		log.Fatalln(err)
	}

	subEventHandler := &subEventHandler{}

	sub.OnPublish(subEventHandler)
	sub.OnJoin(subEventHandler)
	sub.OnLeave(subEventHandler)

	err = sub.Subscribe()
	if err != nil {
		log.Fatalln(err)
	}

AMBIL_DAN_KIRIM_COMMAND:
	commandCUR, err := db.Query("SELECT command_id,deploy_id,command_type,target,payload FROM command_center WHERE start_at=0")
	if err != nil {
		fmt.Println(err)
		panic(err.Error())
	}

	for commandCUR.Next() {
		var commandID, deployID, commandType string
		var target, payload string
		err = commandCUR.Scan(&commandID, &deployID, &commandType, &target, &payload)
		if err != nil {
			fmt.Println(err)
			continue
		}
		cmd := map[string]interface{}{
			"from":    "0",
			"order":   commandType,
			"target":  target,
			"payload": payload,
		}
		cmdd, _ := json.Marshal(cmd)
		sub.Publish(cmdd)
		_, err := db.Query("update command_center set start_at=$1 where deploy_id='t-1'", time.Now().Unix())
		fmt.Println(err)
	}
	time.Sleep(1 * time.Second)
	goto AMBIL_DAN_KIRIM_COMMAND
}
